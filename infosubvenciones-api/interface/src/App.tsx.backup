import { useEffect, useMemo, useState } from "react";
import { v4 as uuidv4 } from "uuid";
import { config } from "./config";
import type { AgentResponse, Filters, Message } from "./types";

const pipelineStages = [
  "Filtrando",
  "Búsqueda semántica",
  "Recuperando",
  "Generando"
];

const presets: { label: string; filters: Partial<Filters> }[] = [
  { label: "Autónomos", filters: { beneficiario: "autónomos" } },
  { label: "PYMES", filters: { beneficiario: "pymes" } },
  { label: "Cultura", filters: { finalidad: "11" } },
  { label: "Comercio", filters: { finalidad: "14" } },
  { label: "Próx. 30 días", filters: { fechaHasta: new Date(Date.now() + 30 * 86400000).toISOString().split("T")[0] } }
];

function App() {
  const [sessionId, setSessionId] = useState<string>(() => uuidv4());
  const [messages, setMessages] = useState<Message[]>([{
    id: uuidv4(),
    role: "assistant",
    content: "Hola, dime qué necesitas y aplicaré los filtros adecuados. Puedes ver o descargar PDFs desde aquí.",
    createdAt: new Date().toISOString()
  }]);
  const [input, setInput] = useState("");
  const [filters, setFilters] = useState<Filters>({});
  const [loading, setLoading] = useState(false);
  const [stageIndex, setStageIndex] = useState<number | null>(null);
  const [selectedPdf, setSelectedPdf] = useState<string | null>(null);
  const [meta, setMeta] = useState<{ model?: string; latencyMs?: number; lastUpdated?: string }>({
    lastUpdated: config.lastUpdated
  });

  useEffect(() => {
    let timer: ReturnType<typeof setInterval>;
    if (loading) {
      setStageIndex(0);
      timer = setInterval(() => {
        setStageIndex((prev) => {
          if (prev === null) return 0;
          return (prev + 1) % pipelineStages.length;
        });
      }, 1200);
    }
    return () => {
      if (timer) clearInterval(timer);
      setStageIndex(null);
    };
  }, [loading]);

  const handleSend = async () => {
    if (!input.trim() || !config.agentEndpoint) return;
    const userMessage: Message = {
      id: uuidv4(),
      role: "user",
      content: input.trim(),
      createdAt: new Date().toISOString()
    };
    setMessages((prev) => [...prev, userMessage]);
    setInput("");
    setLoading(true);

    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), config.requestTimeoutMs);
      const res = await fetch(config.agentEndpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Basic ${btoa(`${config.basicAuthUser}:${config.basicAuthPass}`)}`
        },
        body: JSON.stringify({ sessionId, message: userMessage.content, filters }),
        signal: controller.signal
      });
      clearTimeout(timeout);

      const data = (await res.json()) as AgentResponse;
      setMeta((prev) => ({
        model: data.meta?.model ?? prev.model,
        latencyMs: data.meta?.latencyMs ?? prev.latencyMs,
        lastUpdated: data.meta?.lastUpdated ?? prev.lastUpdated
      }));

      const assistantMessage: Message = {
        id: uuidv4(),
        role: "assistant",
        content: data.error ? data.error.message : data.answer,
        response: data,
        createdAt: new Date().toISOString()
      };
      setMessages((prev) => [...prev, assistantMessage]);
    } catch (err: unknown) {
      const assistantMessage: Message = {
        id: uuidv4(),
        role: "assistant",
        content: "Hubo un problema al procesar tu consulta. Intenta de nuevo.",
        createdAt: new Date().toISOString()
      };
      setMessages((prev) => [...prev, assistantMessage]);
    } finally {
      setLoading(false);
      setStageIndex(null);
    }
  };

  const handleReset = () => {
    setSessionId(uuidv4());
    setMessages([{
      id: uuidv4(),
      role: "assistant",
      content: "Contexto reiniciado. ¿En qué puedo ayudarte?",
      createdAt: new Date().toISOString()
    }]);
    setFilters({});
    setSelectedPdf(null);
  };

  const appliedFiltersLine = useMemo(() => {
    const entries = Object.entries(filters).filter(([, val]) => val !== undefined && val !== "");
    if (!entries.length) return "Sin filtros";
    return entries.map(([k, v]) => `${k}: ${v}`).join(" • ");
  }, [filters]);

  return (
    <div className="app-shell">
      <header className="topbar">
        <div>
          <p className="eyebrow">SISTEMA DE CONSULTAS</p>
          <h1>Buscador Inteligente de Subvenciones</h1>
          <p className="meta">Encuentra ayudas para tu negocio • Powered by IA</p>
        </div>
        <div className="badges">
          {meta.model && <span className="badge info">Modelo: {meta.model}</span>}
          {typeof meta.latencyMs === "number" && (
            <span className="badge neutral">{(meta.latencyMs / 1000).toFixed(1)}s</span>
          )}
          {meta.lastUpdated && <span className="badge neutral">Últ. act: {meta.lastUpdated}</span>}
          <button className="ghost" onClick={handleReset}>Resetear chat</button>
        </div>
      </header>

      <div className="layout">
        <main className="chat-panel">
          <div className="filters">
            <div className="filter-fields">
              <input
                placeholder="Región"
                value={filters.region ?? ""}
                onChange={(e) => setFilters((f) => ({ ...f, region: e.target.value }))}
              />
              <input
                placeholder="Beneficiario"
                value={filters.beneficiario ?? ""}
                onChange={(e) => setFilters((f) => ({ ...f, beneficiario: e.target.value }))}
              />
              <input
                placeholder="Finalidad (11/14)"
                value={filters.finalidad ?? ""}
                onChange={(e) => setFilters((f) => ({ ...f, finalidad: e.target.value }))}
              />
              <input
                type="date"
                placeholder="Desde"
                value={filters.fechaDesde ?? ""}
                onChange={(e) => setFilters((f) => ({ ...f, fechaDesde: e.target.value }))}
              />
              <input
                type="date"
                placeholder="Hasta"
                value={filters.fechaHasta ?? ""}
                onChange={(e) => setFilters((f) => ({ ...f, fechaHasta: e.target.value }))}
              />
              <input
                placeholder="Cuantía mín"
                type="number"
                value={filters.cuantiaMin ?? ""}
                onChange={(e) => setFilters((f) => ({ ...f, cuantiaMin: e.target.value ? Number(e.target.value) : undefined }))}
              />
              <input
                placeholder="Cuantía máx"
                type="number"
                value={filters.cuantiaMax ?? ""}
                onChange={(e) => setFilters((f) => ({ ...f, cuantiaMax: e.target.value ? Number(e.target.value) : undefined }))}
              />
            </div>
            <div className="chips">
              {presets.map((p) => (
                <button
                  key={p.label}
                  className="chip"
                  onClick={() => setFilters((f) => ({ ...f, ...p.filters }))}
                >
                  {p.label}
                </button>
              ))}
              <span className="applied">Filtros aplicados: {appliedFiltersLine}</span>
            </div>
          </div>

          {stageIndex !== null && (
            <div className="status-bar">
              {pipelineStages.map((stage, idx) => (
                <span key={stage} className={idx === stageIndex ? "stage active" : "stage"}>{stage}</span>
              ))}
            </div>
          )}

          <div className="messages">
            {messages.map((msg) => (
              <MessageBubble
                key={msg.id}
                message={msg}
                onSelectPdf={setSelectedPdf}
              />
            ))}
          </div>

          <div className="composer">
            <textarea
              placeholder="Describe tu consulta..."
              value={input}
              onChange={(e) => setInput(e.target.value)}
              disabled={loading}
            />
            <button className="primary" onClick={handleSend} disabled={loading || !input.trim()}>
              {loading ? "Procesando" : "Enviar"}
            </button>
          </div>
        </main>

        <aside className={`viewer ${selectedPdf ? "open" : ""}`}>
          {selectedPdf ? (
            <div className="viewer-body">
              <div className="viewer-header">
                <h3>PDF</h3>
                <a className="ghost" href={selectedPdf} target="_blank" rel="noreferrer">Descargar</a>
                <button className="ghost" onClick={() => setSelectedPdf(null)}>Cerrar</button>
              </div>
              <object data={selectedPdf} type="application/pdf" className="pdf-frame">
                <p>No se pudo previsualizar. <a href={selectedPdf} target="_blank" rel="noreferrer">Descargar PDF</a></p>
              </object>
            </div>
          ) : (
            <div className="viewer-empty">
              <p>Selecciona "Ver PDF" para abrirlo aquí.</p>
            </div>
          )}
        </aside>
      </div>
      <footer className="footer">
        <p>Desarrollado por cristianjrojas@gmail.com</p>
      </footer>
    </div>
  );
}

function MessageBubble({ message, onSelectPdf }: { message: Message; onSelectPdf: (url: string) => void }) {
  const isUser = message.role === "user";
  return (
    <div className={isUser ? "bubble user" : "bubble assistant"}>
      <p className="bubble-text">{message.content}</p>
      {!isUser && message.response && (
        <div className="response-block">
          <div className="meta-line">Filtros aplicados: {formatFilters(message.response.appliedFilters)}</div>
          {message.response.citations?.length ? (
            <div className="citations">
              {message.response.citations.map((c, idx) => (
                <button key={idx} className="citation" onClick={() => onSelectPdf(c.pdfUrl)}>
                  {c.articulo ? `Art. ${c.articulo}` : "Cita"}{c.page ? ` • p.${c.page}` : ""}
                </button>
              ))}
            </div>
          ) : null}
          {message.response.convocatorias?.length ? (
            <div className="results">
              {message.response.convocatorias.slice(0, 5).map((c) => (
                <div key={c.id} className="result-card">
                  <div>
                    <p className="result-title">{c.titulo}</p>
                    <p className="result-meta">ID {c.id}{c.deadline ? ` • Plazo ${formatDate(c.deadline)}` : ""}{c.region ? ` • ${c.region}` : ""}{c.beneficiario ? ` • ${c.beneficiario}` : ""}</p>
                    <p className="result-meta">{c.cuantia ? `Cuantía: ${c.cuantia}` : ""}{typeof c.relevance === "number" ? ` • Score ${c.relevance.toFixed(2)}` : ""}</p>
                  </div>
                  <div className="actions">
                    <button className="primary" onClick={() => onSelectPdf(c.pdfUrl)}>Ver PDF</button>
                    <a className="ghost" href={c.pdfUrl} target="_blank" rel="noreferrer">Descargar</a>
                  </div>
                </div>
              ))}
            </div>
          ) : null}
          {message.response.error && (
            <p className="error">{message.response.error.message}</p>
          )}
        </div>
      )}
    </div>
  );
}

function formatFilters(filters?: Filters) {
  if (!filters) return "Sin filtros";
  const parts = Object.entries(filters).filter(([, v]) => v !== undefined && v !== "").map(([k, v]) => `${k}: ${v}`);
  return parts.length ? parts.join(" • ") : "Sin filtros";
}

function formatDate(value: string) {
  try {
    return new Intl.DateTimeFormat("es-ES").format(new Date(value));
  } catch {
    return value;
  }
}

export default App;
